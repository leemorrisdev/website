<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Lee Morris</title>
    <link>http://localhost:1313/post/</link>
    <description>Recent content in Posts on Lee Morris</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-gb</language>
    <lastBuildDate>Mon, 04 Jan 2016 21:41:03 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Testing with mocks</title>
      <link>http://localhost:1313/post/testing-with-mocks/</link>
      <pubDate>Mon, 04 Jan 2016 21:41:03 +0000</pubDate>
      
      <guid>http://localhost:1313/post/testing-with-mocks/</guid>
      <description>&lt;p&gt;I stumbled on an article whilst browsing hacker news earlier that I found interesting.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://arlobelshee.com/the-no-mocks-book/&#34;&gt;http://arlobelshee.com/the-no-mocks-book/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The article argues that if, as a developer, you come up against code requiring a mock, then the code should be refactored in a manner that allows you to avoid using a mock.&lt;/p&gt;

&lt;p&gt;My problem is that we have to make a big assumption right off the bat that mocks are bad.  I don&amp;rsquo;t view mocks as inherently evil, or that the use of mocks tells us anything in particular about the codebase.  In many cases they are a simple, quick and effective way of setting up your tests, avoiding the need to create interfaces purely so you can create test versions of classes.&lt;/p&gt;

&lt;p&gt;I do find mocks to be fairly brittle at times, as they can require a lot of extra work to maintain when refactoring API&amp;rsquo;s, but it can be a price worth paying.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Storing a collection of strings using JPA</title>
      <link>http://localhost:1313/post/storing-a-collection-of-strings-using-jpa/</link>
      <pubDate>Mon, 19 Oct 2015 20:55:03 +0000</pubDate>
      
      <guid>http://localhost:1313/post/storing-a-collection-of-strings-using-jpa/</guid>
      <description>&lt;p&gt;I had a requirement which required me to store a collection of IP addresses against a given entity.  On the face of it, this looks like a job for @OneToMany but the IP’s internally are just stored as Strings, and it felt wasteful to wrap this string up in an object with an ID just for the database.&lt;/p&gt;

&lt;p&gt;A quick google on this problem suggested I use @ElementCollection with @CollectionTable to handle the one-to-many mapping for me.  I did this but immediately noticed the generated table didn’t have a primary key, which according to the documentation is not supported.  This smells a little for me, as well as the fact I’m going to have to JOIN that table just to retrieve a few strings.&lt;/p&gt;

&lt;p&gt;Rather than using these annotations, I decided on using a JPA AttributeConverter instead.  An attribute converter can be used to convert from one type to another and can be attached to fields as required.  Internally, I want to represent the IP addresses as a Set&lt;String&gt;, and decided I could simply convert this to a delimited list comprising of a single field in the database.  This saves me an extra JOIN statement, and also removes my primary key issue.&lt;/p&gt;

&lt;p&gt;My converter class is as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Converter
public class StringSetConverter implements AttributeConverter&amp;lt;Set, String&amp;gt; {

    private static final String SEPARATOR = &amp;quot;,&amp;quot;;

    @Override
    public String convertToDatabaseColumn(Set attribute) {

        if(attribute == null) {
            return &amp;quot;&amp;quot;;
        }

        StringBuilder sb = new StringBuilder();

        Iterator&amp;lt;?&amp;gt; itemIterator = attribute.iterator();

        while(itemIterator.hasNext()) {
            sb.append(itemIterator.next());
            if(itemIterator.hasNext()) {
                sb.append(SEPARATOR);
            }
        }

        return sb.toString();
    }

    @Override
    public Set convertToEntityAttribute(String dbData) {
        if(StringUtils.isEmptyOrWhitespaceOnly(dbData)) {
            return Sets.newHashSet();
        }
        return Sets.newHashSet(dbData.split(SEPARATOR));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To assign the converter, you need to add the following to your field:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Column
@Convert(converter = StringSetConverter.class)
private Set allowedSourceIps;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, I can add my IP addresses to the Set and they’ll be represented as a pipe delimited String in my column:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Sets.newHashSet(&amp;quot;192.168.1.2&amp;quot;, &amp;quot;192.168.1.3&amp;quot;) ---&amp;gt; &#39;192.168.1.2,192.168.1.3&#39;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>